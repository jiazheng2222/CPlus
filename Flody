
http://www.cnblogs.com/hxsyl/p/3270401.html

案例中，想要经过A->D->C->B来找到最短路径。那么我们有两种方式来更新：
1：
D A C 来查询到A、C的最短路径
C A B 来达到最终目的
2:
C B D 来查询到B、D的最短路径
D A B 来达到目的

由此看出，并不一定要先D再C；也可以先C再D。那么Flody前后两次来松弛D，C的最短路径

for (int k=0; k<n; ++k) {
  for (int i=0; i<n; ++i) {
    for (int j=0; j<n; ++j) {
      if (dist[i][k] + dist[k][j] < dist[i][j] ) {
所以这里特别注意，使用k在最外层，用来松弛经过k的所有边的情况。比如经过C点可以松弛B、 D，经过D点可以松弛A、C。也就是说经过当前点
如果存在可以松弛的可能性，那么我就松弛经过该点的其他两个点。 我更新完之后就再与当前点无关了，而且随后的所有枚举情况可以使用到我刚才更新的最短路径；
而如果i,j选定后再利用k来松弛，那么如果之前经过k点的最短路径没有找到，以后再也没有机会来更新A、B的距离了！！！
        dist[i][j] = dist[i][k] + dist[k][j];
      }
    }
  }
